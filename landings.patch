diff --git a/ArduPlane/altitude.cpp b/ArduPlane/altitude.cpp
index 6387edef12..9a40b11480 100644
--- a/ArduPlane/altitude.cpp
+++ b/ArduPlane/altitude.cpp
@@ -635,9 +635,9 @@ void Plane::rangefinder_height_update(void)
         }
         // correct the range for attitude (multiply by DCM.c.z, which
         // is cos(roll)*cos(pitch))
-        rangefinder_state.height_estimate = distance * ahrs.get_rotation_body_to_ned().c.z;
+        rangefinder_state.height_estimate = distance; //* ahrs.get_rotation_body_to_ned().c.z;
 
-        rangefinder_terrain_correction(rangefinder_state.height_estimate);
+        //rangefinder_terrain_correction(rangefinder_state.height_estimate);
 
         // we consider ourselves to be fully in range when we have 10
         // good samples (0.2s) that are different by 5% of the maximum
diff --git a/ArduPlane/commands_logic.cpp b/ArduPlane/commands_logic.cpp
index 299f5e004c..2a13fa6eae 100644
--- a/ArduPlane/commands_logic.cpp
+++ b/ArduPlane/commands_logic.cpp
@@ -251,12 +251,25 @@ bool Plane::verify_command(const AP_Mission::Mission_Command& cmd)        // Ret
             return landing.verify_abort_landing(prev_WP_loc, next_WP_loc, current_loc, auto_state.takeoff_altitude_rel_cm, throttle_suppressed);
 
         } else {
-            // use rangefinder to correct if possible
-            float height = height_above_target() - rangefinder_correction();
-            // for flare calculations we don't want to use the terrain
-            // correction as otherwise we will flare early on rising
-            // ground
-            height -= auto_state.terrain_correction;
+
+            float height;
+
+            if (landing.get_is_simple_landing() == 1) {
+                if (g.rangefinder_landing && rangefinder_state.in_range){
+                    height = rangefinder_state.height_estimate;   
+                }
+                else {
+                    height = height_above_target();
+                }
+            }
+            else {
+                // use rangefinder to correct if possible
+                height = height_above_target() - rangefinder_correction();
+                // for flare calculations we don't want to use the terrain
+                // correction as otherwise we will flare early on rising
+                // ground
+                height -= auto_state.terrain_correction;
+            }
             return landing.verify_land(prev_WP_loc, next_WP_loc, current_loc,
                                        height, auto_state.sink_rate, auto_state.wp_proportion, auto_state.last_flying_ms, arming.is_armed(), is_flying(),
                                        g.rangefinder_landing && rangefinder_state.in_range);
diff --git a/libraries/AP_Landing/AP_Landing.cpp b/libraries/AP_Landing/AP_Landing.cpp
index e3947d40f6..e875bb0b07 100644
--- a/libraries/AP_Landing/AP_Landing.cpp
+++ b/libraries/AP_Landing/AP_Landing.cpp
@@ -163,6 +163,15 @@ const AP_Param::GroupInfo AP_Landing::var_info[] = {
     // @User: Advanced
     AP_GROUPINFO("WIND_COMP", 18, AP_Landing, wind_comp, 50),
 
+    // // @Param: SMPL_LAND
+    // // @DisplayName: Headwind Compensation when Landing 2
+    // // @Description: This param controls how much headwind compensation is used when landing.  Headwind speed component multiplied by this parameter is added to TECS_LAND_ARSPD command.  Set to Zero to disable.  Note:  The target landing airspeed command is still limited to ARSPD_FBW_MAX.
+    // // @Range: 0 100
+    // // @Units: %
+    // // @Increment: 1
+    // // @User: Advanced
+    AP_GROUPINFO("SMPL_LAND", 19, AP_Landing, is_simple_landing, 0),
+
     // @Param: TYPE
     // @DisplayName: Auto-landing type
     // @Description: Specifies the auto-landing type to use
diff --git a/libraries/AP_Landing/AP_Landing.h b/libraries/AP_Landing/AP_Landing.h
index 554a883a27..5682aa7efb 100644
--- a/libraries/AP_Landing/AP_Landing.h
+++ b/libraries/AP_Landing/AP_Landing.h
@@ -105,6 +105,7 @@ public:
     int8_t get_abort_throttle_enable(void) const { return abort_throttle_enable; }
     int8_t get_flap_percent(void) const { return flap_percent; }
     int8_t get_throttle_slewrate(void) const { return throttle_slewrate; }
+    int8_t get_is_simple_landing(void) const { return is_simple_landing; }
     bool is_commanded_go_around(void) const { return flags.commanded_go_around; }
     bool is_complete(void) const;
     void set_initial_slope(void) { initial_slope = slope; }
@@ -169,6 +170,7 @@ private:
     AP_Int8 type;
     AP_Int8 flare_effectivness_pct;
     AP_Float wind_comp;
+    AP_Int8 is_simple_landing;
 
     // Land Type STANDARD GLIDE SLOPE
 
diff --git a/libraries/AP_Terrain/AP_Terrain.cpp b/libraries/AP_Terrain/AP_Terrain.cpp
index 9cf721383f..55eddd19ad 100644
--- a/libraries/AP_Terrain/AP_Terrain.cpp
+++ b/libraries/AP_Terrain/AP_Terrain.cpp
@@ -26,10 +26,14 @@
 #include <AP_AHRS/AP_AHRS.h>
 #include <AP_Vehicle/AP_Vehicle_Type.h>
 #include <AP_Filesystem/AP_Filesystem.h>
+#include <AP_RangeFinder/AP_RangeFinder.h>
+#include <AP_Vehicle/AP_Vehicle.h>
+// #include <ArduPlane/Plane.h>
 
 extern const AP_HAL::HAL& hal;
 
 AP_Terrain *AP_Terrain::singleton;
+RangeFinder rangefinder;
 
 #if APM_BUILD_TYPE(APM_BUILD_ArduSub)
 #define TERRAIN_ENABLE_DEFAULT 0
@@ -235,6 +239,15 @@ bool AP_Terrain::height_terrain_difference_home(float &terrain_difference, bool
 bool AP_Terrain::height_above_terrain(float &terrain_altitude, bool extrapolate)
 {
     float terrain_difference;
+    float distance = rangefinder.distance_orient(ROTATION_PITCH_270);
+    
+    if (rangefinder.status_orient(ROTATION_PITCH_270) == RangeFinder::Status::Good) {
+
+        terrain_altitude = distance;
+        // force rangefinder only for now
+        return true;
+    }
+
     if (!height_terrain_difference_home(terrain_difference, extrapolate)) {
         return false;
     }
@@ -359,11 +372,12 @@ void AP_Terrain::update(void)
     }
 
     // update capabilities and status
+
     if (allocate()) {
-        if (!pos_valid) {
+        if (!pos_valid && !(rangefinder.status_orient(ROTATION_PITCH_270) == RangeFinder::Status::Good)) {
             // we don't know where we are
             system_status = TerrainStatusUnhealthy;
-        } else if (!terrain_valid) {
+        } else if (!terrain_valid && !(rangefinder.status_orient(ROTATION_PITCH_270) == RangeFinder::Status::Good)) {
             // we don't have terrain data at current location
             system_status = TerrainStatusUnhealthy;
         } else {
diff --git a/libraries/AP_Terrain/AP_Terrain.h b/libraries/AP_Terrain/AP_Terrain.h
index c2919e4bea..2382d7693b 100644
--- a/libraries/AP_Terrain/AP_Terrain.h
+++ b/libraries/AP_Terrain/AP_Terrain.h
@@ -21,7 +21,7 @@
 #if HAVE_FILESYSTEM_SUPPORT && defined(HAL_BOARD_TERRAIN_DIRECTORY)
 #define AP_TERRAIN_AVAILABLE 1
 #else
-#define AP_TERRAIN_AVAILABLE 0
+#define AP_TERRAIN_AVAILABLE 1
 #endif
 #endif
 
